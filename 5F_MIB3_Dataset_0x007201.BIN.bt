//------------------------------------------------//--- 010 Editor v12.0 Binary Template////      File: 0x007201.BIN//   Authors: Alex Strelets, Joao Almeida//   Version: 0.1//   Purpose: Parse the contents of the MIB3 Sound Channels and Effects//   Category: //   File Mask: //   ID Bytes: //   History: 0.1 - Initial version//            0.2 - Small tweaks performed.////   Considering the following structure://     Version - 0-3 bytes (values from 0x00000000 to 0x7F7F7F7F).//     Data is 4-2047 bytes in hexadecimal format (each byte has values from 0x00 to 0xFF).//     Checksum - 2048-2051 bytes according to CRC-32 (values from 0x00000000 to 0xFFFFFFFF).//////------------------------------------------------BigEndian();string getSignalflow(int type) {    switch (type) {        case 0x10: return "2ch (4.0)";        case 0x20: return "4ch (8.0)";        case 0x21: return "4ch / 2ch compatible (8.0 / 4.0)";        case 0x30: return "6ch center sub (9.1)";        case 0x31: return "6ch center sub / 2/4ch compatible (9.1 / 8.0 / 4.0)";        case 0x32: return "6ch doublesub (8.2)";        case 0x33: return "6ch doublesub / 2/4ch compatible (8.2 / 8.0 / 4.0)";        case 0x34: return "6ch frontwoofer (9.1)";        case 0x35: return "6ch frontwoofer / 2/4ch compatible (9.1 / 8.0 / 4.0)";        default:   return "Unknown";        }}string getFilterType(int type) {    switch (type) {        case 0x00: return "Bypass";            case 0x01: return "Shelf 1 High";            case 0x02: return "Shelf 2 High";            case 0x03: return "Shelf 1 Low";           case 0x04: return "Shelf 2 Low";            case 0x05: return "Peak 1";            case 0x06: return "Peak 2";            case 0x07: return "Highpass 1";        case 0x08: return "Highpass 2";        case 0x09: return "Lowpass 1";        case 0x0A: return "Lowpass 2";        case 0x10: return "Coefficients";        default:   return "Unknown";    }}typedef struct {    ubyte type <bgcolor=cAqua, read=getFilterType>;    ubyte quality <bgcolor=cLtGreen>;   // [0.2 .. 5]    ushort frequency <bgcolor=cGreen>;  // [20 .. 20000]    ubyte gainOffset <bgcolor=cDkAqua>; // [-6 .. +6]    ubyte maxGain <bgcolor=cDkAqua>;    // [0  .. 15]} EQ;typedef struct {    ubyte type <bgcolor=cAqua, read=getFilterType>;    ubyte quality <bgcolor=cLtGreen>;    ushort frequency <bgcolor=cGreen>;    ubyte gain[19] <bgcolor=cDkAqua>;} EQ2;typedef struct {    ubyte type <bgcolor=cAqua, read=getFilterType>;    ubyte quality <bgcolor=cLtGreen>;    ushort frequency <bgcolor=cGreen>;    byte gain <bgcolor=cDkAqua>; // [-12.5 .. 12.5]} EQ3;float calcQuality (ubyte value) {    return (float) value / 10;}float calcGain (byte value) {    return (float) value / 12.5;}float calcAbsGain (ubyte value) {    return (float) value / 12.5;}float calcMaxGain (ubyte value) {    return (float) value / 15;}void printEQ2(EQ2 &s, string name, int unknownFlag) {    Printf("\n%s\nType\tQuality\tFrequency\n", name);    Printf("==================================\n");    Printf("%s\t%7.1f\t %6gHz\n",         getFilterType(s.type),         calcQuality(s.quality),         s.frequency);     Printf("==================================\n");    if (!unknownFlag) {        Printf("Volume:\t");        for (i = 0; i < 19; i++) {            Printf("%5g ", 18 - i);        }        Printf("\n");    }        Printf("Gain:\t");        for (i = 0; i < 19; i++) {            Printf("%5.2f ", calcAbsGain(s.gain[i]));         }    Printf("\n");}// File read starts here//char DatasetVersion[4];byte Signalflow <bgcolor=cDkGreen, read=getSignalflow>;EQ ToneControls[5] <bgcolor=cDkGreen>;ubyte Subwoofer_maxGain <bgcolor=cLtYellow>; // subwoofer gain ???EQ2 LoudnessLow <bgcolor=cDkGreen>;//It seems that LoudnessHigh is very different from what it was previously. We'll leave it like this for now. There are 42 hex missing to be interpreted////EQ2 LoudnessHigh;struct {    ubyte value[19] <bgcolor=cGray>;    char UnkownLoudnessHigh[42];} UnkownLoudnessHigh;struct {    ubyte value[19] <bgcolor=cGray>;} GALA[7];EQ2 UnknownFilter_1;// UnkownFilter_2 is also very Different from what it was. There is now a new structure with 15 filters - to be confirmed when they are applied// These are not different by channel - Might be an overall equalizer to the system?//EQ3 UnknownFilter_2[15];// This boy is a bit lost in herebyte UnkownFilter_2_Byte;struct {    EQ3 Filter1;    ubyte Filter1_coefficients[16] <bgcolor=cDkGray>;    EQ3 Filter2;    ubyte Filter2_coefficients[16] <bgcolor=cDkGray>;    EQ3 Filter3;    ubyte Filter3_coefficients[16] <bgcolor=cDkGray>;    EQ3 Filter4;    EQ3 Filter5;    EQ3 Filter6;    // MIB3 only has 6 filters per channel    //    // EQ3 Filter7;    byte Gain <bgcolor=cLtYellow>;    ubyte Delay <bgcolor=cYellow>;    ubyte Phase <bgcolor=cDkYellow>;} CarEQ[18];// Skipping this for now//// FSeek(0x50D);// one of those bytes could be "Limiter THDmax" [0 .. 30]// We have 5 Bytes that we're not sure what they do here//struct {    ubyte unknown_byte <bgcolor=cPurple>;} UnkownDRCByte[5];struct {    ubyte attackTime <bgcolor=cDkGreen>;    ushort releaseTime <bgcolor=cGreen>;    ubyte threshold <bgcolor=cLtGreen>;    ubyte holdTime <bgcolor=cAqua>;} DRC[6];// We have 1 Bytes that we're not sure what they do here//ubyte unknown_byte26 <bgcolor=cPurple>;// We have 6 (Channels) x 5 (Filters) on MIB3. Additinal exploration required //struct {    EQ3 Filter1;    EQ3 Filter2;    EQ3 Filter3;    EQ3 Filter4;    byte Gain <bgcolor=cLtYellow>;    ubyte Delay <bgcolor=cYellow>;    ubyte Phase <bgcolor=cDkYellow>;} UnknownFilter_3[6];FSeek(FileSize() - 4);//struct {//    char major <bgcolor=cDkBlue>;//    char minor <bgcolor=cDkBlue>;//} DatasetVersion;// ushort checksum <bgcolor=cDkRed>;/////////////////////////// PARSING FINISHED ///////////////////////////local int i = 0;local int j = 0;local int k = 0;Printf("\nDataset Version: %s\n",DatasetVersion);Printf("\nSIGNAL FLOW: %s\n", getSignalflow(Signalflow));Printf("\nTONE CONTROLS\nType\tQuality\tFrequency\t  MaxGain\tGainOffset\n");Printf("===========================================================\n");for (i = 0; i < 5; i++) {    Printf("%s\t%7.1f\t %6gHz\t  %7.2f\t%10.2f\n",        getFilterType(ToneControls[i].type),         calcQuality(ToneControls[i].quality),         ToneControls[i].frequency,         calcMaxGain(ToneControls[i].maxGain),        ToneControls[i].gainOffset / 12);}Printf("===========================================================\n");Printf("Subwoofer\t\t\t  %7.2f\n", calcMaxGain(Subwoofer_maxGain));printEQ2(LoudnessLow, "LOUDNESS LOW", false);// LoudnessHigh seems to have a different format. Still to be found...//// printEQ2(LoudnessHigh, "LOUDNESS HIGH", false);Printf("\nGALA (SPEED-DEPENDENT VOLUME CONTROL)");Printf("\nLevel\t Gain\n");Printf("==========================================");Printf("==========================================");Printf("==========================================\n");for ( i = 0; i < 7; i++ ) {    Printf("%i\t", i+1);    for ( j = 0; j < 19; j++ ) {        Printf("%5.2f ", calcAbsGain(GALA[i].value[j]));    }    Printf("\n");};Printf("==========================================");Printf("==========================================");Printf("==========================================\n");printEQ2(UnknownFilter_1, "UNKNOWN FILTER 1", true);// Unkown Filter 2 is different on MIB3 - still to be confirmed. Adding a print for these 15 new filters// printEQ2(UnknownFilter_2, "UNKNOWN FILTER 2", true);// Adding new logic to print new(?) MIB3 Filters. Still TBC what these arePrintf("\n\n");Printf("UNKNOWN FILTER 2\n\n");Printf("------------------------------------------------\n");Printf("Type\tQuality\t Frequency\t       Gain\n");        Printf("================================================\n");for (i = 0; i < 15; i++) {Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",      getFilterType(UnknownFilter_2[i].type),      calcQuality(UnknownFilter_2[i].quality),      UnknownFilter_2[i].frequency,     calcGain(UnknownFilter_2[i].gain));}Printf("================================================\n\n");Printf("\n\n");for (j = 0; j < 3; j++) {    Printf("[ CarEQ%i ]\n\n", j+1);    for (i = 0; i < 6; i++) {        k = j * 6 + i;        Printf("CHANNEL %i [ Gain: %5.2f Delay: %2gms Phase: %3gÂ°]\n",             i+1,             calcGain(CarEQ[k].Gain),             CarEQ[k].Delay,             CarEQ[k].Phase > 0 ? 180 : 0);        Printf("------------------------------------------------\n");        Printf("Type\tQuality\t Frequency\t       Gain\n");                Printf("================================================\n");        Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",             getFilterType(CarEQ[k].Filter1.type),             calcQuality(CarEQ[k].Filter1.quality),             CarEQ[k].Filter1.frequency,            calcGain(CarEQ[k].Filter1.gain));         Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",             getFilterType(CarEQ[k].Filter2.type),             calcQuality(CarEQ[k].Filter2.quality),             CarEQ[k].Filter2.frequency,            calcGain(CarEQ[k].Filter2.gain));         Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",             getFilterType(CarEQ[k].Filter3.type),             calcQuality(CarEQ[k].Filter3.quality),             CarEQ[k].Filter3.frequency,            calcGain(CarEQ[k].Filter3.gain));         Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",             getFilterType(CarEQ[k].Filter4.type),             calcQuality(CarEQ[k].Filter4.quality),             CarEQ[k].Filter4.frequency,            calcGain(CarEQ[k].Filter4.gain));         Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",             getFilterType(CarEQ[k].Filter5.type),             calcQuality(CarEQ[k].Filter5.quality),             CarEQ[k].Filter5.frequency,            calcGain(CarEQ[k].Filter5.gain));         Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",             getFilterType(CarEQ[k].Filter6.type),             calcQuality(CarEQ[k].Filter6.quality),             CarEQ[k].Filter6.frequency,            calcGain(CarEQ[k].Filter6.gain)); //        Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n", //            getFilterType(CarEQ[k].Filter7.type), //            calcQuality(CarEQ[k].Filter7.quality), //            CarEQ[k].Filter7.frequency,//            calcGain(CarEQ[k].Filter7.gain));         Printf("================================================\n\n");    }}Printf("DYNAMIC RANGE COMPRESSION\n");Printf("Channel\t Threshold\t   Attack\t    Hold\tRelease\n");Printf("========================================================\n");for (i = 0; i < 6; i++) {    Printf("%i\t     %5.1f\t   %6.1f\t  %6.1f\t   %4g\n",         i+1,        DRC[i].threshold / -20,         // [-20 .. 0 ]        (float) DRC[i].attackTime / 20, // [0.5 .. 20]        (float) DRC[i].holdTime / 20,   // [0.5 .. 20]        DRC[i].releaseTime              // [5 .. 2000]    );}Printf("========================================================");// Adding new logic to print new(?) MIB3 Filters. Still TBC what these arePrintf("\n\n");Printf("UNKNOWN FILTER 3\n\n");for (i = 0; i < 6; i++) {     Printf("CHANNEL %i [ Gain: %5.2f Delay: %2gms Phase: %3gÂ°]\n",          i+1,          calcGain(UnknownFilter_3[i].Gain),          UnknownFilter_3[i].Delay,          UnknownFilter_3[i].Phase > 0 ? 180 : 0);     Printf("------------------------------------------------\n");     Printf("Type\tQuality\t Frequency\t       Gain\n");             Printf("================================================\n");     Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",          getFilterType(UnknownFilter_3[i].Filter1.type),          calcQuality(UnknownFilter_3[i].Filter1.quality),          UnknownFilter_3[i].Filter1.frequency,         calcGain(UnknownFilter_3[i].Filter1.gain));      Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",          getFilterType(UnknownFilter_3[i].Filter2.type),          calcQuality(UnknownFilter_3[i].Filter2.quality),          UnknownFilter_3[i].Filter2.frequency,         calcGain(UnknownFilter_3[i ].Filter2.gain));      Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",          getFilterType(UnknownFilter_3[i].Filter3.type),          calcQuality(UnknownFilter_3[i].Filter3.quality),          UnknownFilter_3[i].Filter3.frequency,         calcGain(UnknownFilter_3[i].Filter3.gain));      Printf("%s\t  %5.1f\t  %6gHz\t      %5.2f\n",          getFilterType(UnknownFilter_3[i].Filter4.type),          calcQuality(UnknownFilter_3[i].Filter4.quality),          UnknownFilter_3[i].Filter4.frequency,         calcGain(UnknownFilter_3[i].Filter4.gain));      Printf("================================================\n\n");    }// Ignoring for now////local ushort file_checksum = Checksum(CHECKSUM_CRCCCITT, 0, FileSize() - 2, -1, -1); // algo, size, length, poly, init //Printf("\n\nFILE CHECKSUM: %.04X", file_checksum);